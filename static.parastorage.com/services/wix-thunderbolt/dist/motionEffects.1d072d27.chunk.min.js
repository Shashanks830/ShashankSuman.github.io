"use strict";
(self.webpackJsonp__wix_thunderbolt_app = self.webpackJsonp__wix_thunderbolt_app || []).push([
    [5097], {
        49828: function(t, e, n) {
            n.r(e), n.d(e, {
                MotionEffectsInit: function() {
                    return m
                },
                MotionEffectsInitSymbol: function() {
                    return c.J0
                },
                MotionEffectsManager: function() {
                    return u
                },
                page: function() {
                    return b
                }
            });
            var i = n(77748),
                s = n(20590),
                r = n(39218),
                o = n(32166),
                a = n(54157),
                c = n(89301),
                h = n(82634);
            const d = t => `${t}-motionEffects`;
            Array.prototype.findLast || Object.defineProperty(Array.prototype, "findLast", {
                value(t, e) {
                    return this.slice(0).reverse().find(e ? t.bind(e) : t)
                }
            });
            class u {
                constructor(t, e, n) {
                    this.isResponsive = e, this.breakpointRanges = [], this.animator = t, this.definitions = {}, this.scrubScenes = {}, this.scrubTriggers = {}, this.callbacks = {}, this.sessionState = {
                        played: new Map,
                        running: new WeakMap
                    }, this.scrubManagers = [], this.activeListeners = [], this.disabledPointerScenes = {}, this.variantValidator = n, this.breakpointChangeHandler = this._breakpointChangeHandler.bind(this)
                }
                _shouldSkipPlayedAnimation(t) {
                    const e = this.sessionState.played.has(t),
                        {
                            playOnce: n,
                            persistOnNav: i
                        } = this.sessionState.played.get(t) || {};
                    return e && (n || i)
                }
                setAnimationStartState(t) {
                    const e = "string" == typeof t ? document.getElementById(t) : t;
                    e && (e.dataset.motionEnter = "done")
                }
                _addAnimatingClass(t) {
                    t && (t.classList.add("is-animating"), this.setAnimationStartState(t))
                }
                _removeAnimatingClass(t) {
                    t && (t.classList.remove("is-animating"), this.setAnimationStartState(t))
                }
                updateDefinitions(t) {
                    Object.assign(this.definitions, t);
                    const e = Object.keys(t);
                    this.updateScrubScenes(e)
                }
                updateScrubScenes(t, e = !1) {
                    if (e) {
                        const t = new Set;
                        for (const e in this.scrubScenes) t.add(this.scrubScenes[e].targetId), this.scrubScenes[e].animation ? .kill();
                        this.scrubScenes = {}, this.animator.clearScrubAnimations(t)
                    }
                    const n = {},
                        i = this.isResponsive ? window.innerWidth : 0;
                    for (const e of t) {
                        const t = this._getEffectVariationForCurrentBreakpoint(e, i);
                        "ScrubAnimationOptions" === t.type && (n[e] = t)
                    }
                    this.scrubScenes = Object.assign(this.scrubScenes, this.animator.createScrubAnimations(n))
                }
                updateScrubManagers(t = {}, e = !1) {
                    this.scrubManagers.length && e && this._killScrubAnimations(), this.scrubManagers.push(...this.animator.startScrubAnimations(t, this.scrubScenes)), this.scrubManagers.forEach((t => {
                        t instanceof h.g && t.config.scenes.forEach((t => {
                            if (t.target && t.centeredToTarget && t.isHitAreaRoot) {
                                const e = t.target.closest("[data-block-level-container]"),
                                    n = t.effectId;
                                e && this.motionViewport && n && (this.disabledPointerScenes[n] || (this.disabledPointerScenes[n] = []), this.disabledPointerScenes[n].push(t), this.motionViewport.observe(e, {
                                    effectId: n,
                                    targetId: t.target.id
                                }))
                            }
                        }))
                    }))
                }
                handleRotation(t, e) {
                    t.dataset.angle = String(e), t.dataset.angleStyleLocation = "style"
                }
                trigger(t = {}, e) {
                    let n = 0;
                    t.scrub ? e ? (this.scrubTriggers = t.scrub, requestAnimationFrame((() => this.updateScrubManagers(t.scrub, e)))) : (Object.assign(this.scrubTriggers, t.scrub), this.updateScrubManagers(t.scrub)) : n = this.isResponsive ? window.innerWidth : 0, t.play ? .length && t.play.forEach((({
                        effectId: t,
                        targetId: e
                    }) => {
                        const i = this._getEffectVariationForCurrentBreakpoint(t, n);
                        i.name && this.playAnimation(i, t, {
                            targetId: e
                        })
                    })), t.resume ? .length && t.resume.forEach((({
                        effectId: t,
                        targetId: e
                    }) => {
                        if (this.disabledPointerScenes[t]) return void this.disabledPointerScenes[t].forEach((t => t.disabled = !1));
                        const i = this._getEffectVariationForCurrentBreakpoint(t, n);
                        i.name && this.resumeOrPlayAnimation(i, t, {
                            targetId: e
                        })
                    })), t.hold ? .length && t.hold.forEach((({
                        effectId: t,
                        targetId: e
                    }) => {
                        if (this.disabledPointerScenes[t]) return void this.disabledPointerScenes[t].forEach((t => t.disabled = !0));
                        const i = this._getEffectVariationForCurrentBreakpoint(t, n);
                        i.name && this.pauseAnimation({ ...i,
                            targetId: e
                        })
                    }))
                }
                init(t, e) {
                    this.breakpointRanges = e, this.stopAnimations(), this.definitions = {}, this.observeBreakpointChange(), this.updateDefinitions(t)
                }
                addDefinition(t, e, n) {
                    this.handleRotation(e, n), this.updateDefinitions(t)
                }
                addEffectCallback(t, e, n) {
                    const i = "animation-end" === e ? "end" : "start";
                    this.callbacks[t] = this.callbacks[t] || {
                        end: [],
                        start: []
                    }, this.callbacks[t][i] ? .push(n)
                }
                clearEffectCallbacks(t) {
                    delete this.callbacks[t]
                }
                observeTargetPlaybackInViewport(t, e) {
                    const n = document.getElementById(e);
                    if (n && this.motionViewport) {
                        const i = n.closest("[data-block-level-container]") || n;
                        this.motionViewport.observe(i, {
                            effectId: t,
                            targetId: e
                        })
                    }
                }
                playAnimation(t, e, n = {}) {
                    const i = { ...t,
                            ...n
                        },
                        {
                            targetId: s,
                            iterations: r
                        } = i,
                        o = d(s);
                    this._shouldSkipPlayedAnimation(o) ? this.setAnimationStartState(s) : 0 !== r ? this._createAndRunSequence(i, e) : this.observeTargetPlaybackInViewport(e, s)
                }
                _createAndRunSequence(t, e = "") {
                    const {
                        name: n,
                        targetId: i,
                        duration: s,
                        delay: r,
                        easing: o,
                        params: a,
                        playOnce: c,
                        persistOnNav: h,
                        iterations: u = 1
                    } = t, l = d(i), f = {
                        name: n,
                        targetId: i,
                        duration: s,
                        delay: r,
                        params: { ...a,
                            easing: o
                        }
                    }, g = {
                        name: "BaseClear",
                        targetId: i,
                        duration: 0,
                        delay: 0,
                        params: {
                            props: "clip,clipPath,webkitClipPath,willChange,opacity,transform,transformOrigin,filter",
                            immediateRender: !1
                        }
                    }, m = this.animator.runSequence([{
                        type: "Animation",
                        data: f
                    }, {
                        type: "Animation",
                        data: g
                    }], {
                        repeat: u - 1,
                        callbacks: {
                            onStart: t => {
                                const n = document.getElementById(i);
                                n && (this._addAnimatingClass(n), this.sessionState.running.set(n, t)), e && this.callbacks[e] ? .start ? .forEach((t => t({
                                    compId: i
                                })))
                            },
                            onComplete: () => {
                                const t = document.getElementById(i);
                                t && (this._removeAnimatingClass(t), this.sessionState.running.delete(t)), e && this.callbacks[e] ? .end ? .forEach((t => t({
                                    compId: i
                                })))
                            },
                            onInterrupt: () => {
                                const t = document.getElementById(i);
                                t && (this._removeAnimatingClass(t), this.sessionState.running.delete(t))
                            }
                        }
                    });
                    this.sessionState.played.set(l, {
                        playOnce: c,
                        persistOnNav: h,
                        instance: m
                    })
                }
                _getEffectVariationForCurrentBreakpoint(t, e) {
                    const n = this.definitions[t].find((t => !t.variants ? .length));
                    return this.variantValidator(n, t, e)
                }
                stopAnimations({
                    skipPersistent: t = !0
                } = {}) {
                    this.sessionState.played.forEach((({
                        persistOnNav: e,
                        instance: n
                    }) => {
                        t && e || this.animator.kill(n.timeline, 1)
                    })), this._killScrubAnimations()
                }
                getSequenceFromState(t) {
                    const e = document.getElementById(t.targetId);
                    return e && this.sessionState.running.get(e)
                }
                resumeOrPlayAnimation(t, e, n = {}) {
                    const i = { ...t,
                            ...n
                        },
                        s = this.getSequenceFromState(i);
                    s ? s.play() : this._createAndRunSequence(i, e)
                }
                pauseAnimation(t) {
                    const e = this.getSequenceFromState(t);
                    e ? .pause()
                }
                _killScrubAnimations() {
                    this.scrubManagers.length && (this.scrubManagers.forEach((t => t.destroy())), this.scrubManagers.length = 0, this.disabledPointerScenes = {})
                }
                clearAnimations() {
                    this.definitions = {}, this._killScrubAnimations(), this.motionViewport ? .disconnect(), this.activeListeners.forEach((t => t.removeEventListener("change", this.breakpointChangeHandler))), this.activeListeners.length = 0, this.scrubTriggers = {}
                }
                clearState() {
                    this.sessionState.played.clear(), this.sessionState.running = new WeakMap
                }
                observeBreakpointChange() {
                    this.breakpointRanges.forEach((t => {
                        const e = (t => {
                                const e = [];
                                return t.max && e.push(`(max-width:${t.max}px)`), t.min && e.push(`(min-width:${t.min}px)`), e.join(" and ")
                            })(t),
                            n = window.matchMedia(e);
                        this.activeListeners.push(n), n.addEventListener("change", this.breakpointChangeHandler)
                    }))
                }
                _breakpointChangeHandler(t) {
                    t.matches && this.updateScrubScenes(Object.keys(this.definitions), !0)
                }
            }
            var l = n(83407),
                f = n(82658);
            const g = function(t, e, n) {
                    return n && this.definitions[e].findLast((t => t.variants ? .some((t => !(t.max && t.max < n) && !(t.min && t.min > n))))) || t
                },
                m = (0, i.Og)([(0, i.KT)(s.Gp, c.UU), (0, i.KT)(s.wk, c.UU), r.Is, o.RV, a.n, (0, i.lq)(l.Qw)], ((t, e, n, i, s, r) => {
                    const o = new Promise((i => {
                        const {
                            animationDefsByCompId: o,
                            isResponsive: a,
                            scrubAnimationBreakpoints: c
                        } = t;
                        r && !s || i(void 0), r.getEffectsInstance().then((t => {
                            const s = e.get() ? .[n] ? ? new u(t, a, g),
                                r = Object.assign({}, ...Object.values(o));
                            s.motionViewport = s.motionViewport ? ? function({
                                manager: t
                            }) {
                                const e = {
                                        entry: i((function(e) {
                                            const i = e.filter((t => {
                                                const {
                                                    isIntersecting: e,
                                                    target: i
                                                } = t;
                                                return e && (n.get(i).isIntersecting = !0), e
                                            })).flatMap((t => s(t.target)));
                                            t.trigger({
                                                resume: i
                                            })
                                        }), 0, "10%"),
                                        exit: i((function(e) {
                                            const i = e.filter((t => {
                                                const {
                                                    isIntersecting: e,
                                                    target: i
                                                } = t;
                                                return e || (n.get(i).isIntersecting = !1), !e
                                            })).flatMap((t => s(t.target)));
                                            t.trigger({
                                                hold: i
                                            })
                                        }), 0, "50%")
                                    },
                                    n = new WeakMap;

                                function i(t, e, n = "0px") {
                                    const i = {
                                        root: null,
                                        rootMargin: n,
                                        threshold: [e]
                                    };
                                    return new window.IntersectionObserver(t, i)
                                }
                                const s = t => Array.from(n.get(t) ? .effects || []);
                                return {
                                    observe: function(i, s) {
                                        const r = n.get(i);
                                        r ? (r.effects.add(s), r.isIntersecting && t.trigger({
                                            resume: [s]
                                        })) : (n.set(i, {
                                            effects: new Set([s]),
                                            isIntersecting: !1
                                        }), e.entry.observe(i), e.exit.observe(i))
                                    },
                                    disconnect: function() {
                                        e.entry.disconnect(), e.exit.disconnect()
                                    }
                                }
                            }({
                                manager: s
                            }), s.init(r, c), e.update((t => ({ ...t,
                                [n]: s
                            }))), i(s)
                        }))
                    }));
                    return s && !(0, f.fU)(i) ? {
                        name: "motionEffectsInit",
                        pageWillUnmount() {},
                        getInstance() {
                            return o
                        }
                    } : {
                        name: "motionEffectsInit",
                        async pageWillUnmount() {
                            const t = await o;
                            t ? .clearAnimations()
                        },
                        getInstance() {
                            return o
                        }
                    }
                }));
            var p = n(16537);
            const b = t => {
                t(p.$.PageWillUnmountHandler, c.J0).to(m)
            }
        },
        82634: function(t, e, n) {
            function i(t, e, n) {
                return Math.min(Math.max(t, n), e)
            }
            n.d(e, {
                g: function() {
                    return d
                }
            });
            let s = 0;
            const r = new Set;

            function o(t, e) {
                if ("onscrollend" in window) return t.addEventListener("scrollend", e),
                    function() {
                        t.removeEventListener("scrollend", e)
                    };
                let n, i = 0;

                function o(t) {
                    clearTimeout(i), i = setTimeout((() => {
                        r.size ? setTimeout(o, 100) : (e(t), i = 0)
                    }), 100)
                }
                return s || (n = function() {
                        const t = t => {
                                for (let e of t.changedTouches) r.add(e.identifier)
                            },
                            e = t => {
                                for (let e of t.changedTouches) r.delete(e.identifier)
                            };
                        return document.addEventListener("touchstart", t, {
                                passive: !0
                            }), document.addEventListener("touchend", e, {
                                passive: !0
                            }),
                            function() {
                                r.clear(), document.removeEventListener("touchstart", t), document.removeEventListener("touchend", e)
                            }
                    }()), s += 1, t.addEventListener("scroll", o),
                    function() {
                        t.removeEventListener("scroll", o), s -= 1, s || n()
                    }
            }

            function a(t, e) {
                this.x = window.scrollX, this.y = window.scrollY, requestAnimationFrame((() => t && t(e)))
            }

            function c(t) {
                t.rect.width = window.document.documentElement.clientWidth, t.rect.height = window.document.documentElement.clientHeight
            }

            function h(t) {
                let e, n, s, r, h, d = !1,
                    u = {
                        x: t.rect.width / 2,
                        y: t.rect.height / 2,
                        vx: 0,
                        vy: 0
                    };
                const l = {
                    x: 0,
                    y: 0
                };
                return t.scenes.forEach((e => {
                    e.target && e.centeredToTarget && (e.transform = function(t, e, n) {
                        return {
                            x(i) {
                                const s = t.left - n.x + t.width / 2,
                                    r = s >= e.width / 2,
                                    o = 2 * (r ? s : e.width - s);
                                return (i - (r ? 0 : s - o / 2)) / o
                            },
                            y(i) {
                                const s = t.top - n.y + t.height / 2,
                                    r = s >= e.height / 2,
                                    o = 2 * (r ? s : e.height - s);
                                return (i - (r ? 0 : s - o / 2)) / o
                            }
                        }
                    }(function(t) {
                        let e = t,
                            n = 0,
                            i = 0;
                        if (e.offsetParent)
                            do {
                                n += e.offsetLeft, i += e.offsetTop, e = e.offsetParent
                            } while (e);
                        return {
                            left: n,
                            top: i,
                            width: t.offsetWidth,
                            height: t.offsetHeight
                        }
                    }(e.target), t.rect, l), d = !0), t.root ? n = function(t) {
                        const e = new ResizeObserver((e => {
                            e.forEach((e => {
                                t.rect.width = e.borderBoxSize[0].inlineSize, t.rect.height = e.borderBoxSize[0].blockSize
                            }))
                        }));
                        return e.observe(t.root, {
                            box: "border-box"
                        }), e
                    }(t) : (s = c.bind(null, t), window.addEventListener("resize", s))
                })), e = function(e) {
                    for (let n of t.scenes)
                        if (!n.disabled) {
                            const s = +i(0, 1, n.transform ? .x(e.x) || e.x / t.rect.width).toPrecision(4),
                                r = +i(0, 1, n.transform ? .y(e.y) || e.y / t.rect.height).toPrecision(4),
                                o = {
                                    x: e.vx,
                                    y: e.vy
                                };
                            n.effect(n, {
                                x: s,
                                y: r
                            }, o)
                        }
                    Object.assign(u, e)
                }, d && (r = a.bind(l, e, u), h = o(document, r)), {
                    tick: e,
                    destroy: function() {
                        t.scenes.forEach((t => t.destroy ? .())), h ? .(), n ? (n.disconnect(), n = null) : (window.removeEventListener("resize", s), s = null), e = null, u = null
                    }
                }
            }
            class d {
                constructor(t = {}) {
                    this.config = { ...t
                    }, this.effect = null, this._nextTick = null;
                    const e = function(t) {
                        let e = !1;
                        return function() {
                            if (!e) return e = !0, window.requestAnimationFrame((() => {
                                e = !1, t()
                            }))
                        }
                    }((() => {
                        this.tick()
                    }));
                    this.config.rect = this.config.root ? {
                        width: this.config.root.offsetWidth,
                        height: this.config.root.offsetHeight
                    } : {
                        width: window.document.documentElement.clientWidth,
                        height: window.document.documentElement.clientHeight
                    }, this.progress = {
                        x: this.config.rect.width / 2,
                        y: this.config.rect.height / 2,
                        vx: 0,
                        vy: 0
                    }, this._measure = t => {
                        this.progress.x = this.config.root ? t.offsetX : t.x, this.progress.y = this.config.root ? t.offsetY : t.y, this.progress.vx = t.movementX, this.progress.vy = t.movementY, this._nextTick = e()
                    }
                }
                start() {
                    this.setupEffect(), this.setupEvent()
                }
                pause() {
                    this.removeEvent()
                }
                tick() {
                    this.effect.tick(this.progress)
                }
                destroy() {
                    this.pause(), this.removeEffect(), this._nextTick && cancelAnimationFrame(this._nextTick)
                }
                setupEvent() {
                    this.removeEvent();
                    (this.config.root || window).addEventListener("pointermove", this._measure, {
                        passive: !0
                    })
                }
                removeEvent() {
                    (this.config.root || window).removeEventListener("pointermove", this._measure)
                }
                setupEffect() {
                    this.removeEffect(), this.effect = h(this.config)
                }
                removeEffect() {
                    this.effect && this.effect.destroy(), this.effect = null
                }
            }
        }
    }
]);
//# sourceMappingURL=https://static.parastorage.com/services/wix-thunderbolt/dist/motionEffects.1d072d27.chunk.min.js.map